/*

	OrthDS.c

	’¼Œð•„†‚ð—p‚¢‚½DS/CDMA’ÊM•ûŽ®‚ÌBER“Á«ƒVƒ~ƒ…ƒŒ[ƒVƒ‡ƒ“ƒvƒƒOƒ‰ƒ€

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

#define N 100000
#define P 11
#define CODE_LENGTH 32
#define SIR -10
#define NUM 0

static unsigned long seed = 1;

#include "rnd.h"
#include "nrnd.h"

void MakeMyData(double* InputData, double* pn, double* OutputData);
void MakeOtherData(double* InputData, double* pn, double* OutputData);
void MyDataDemodulation(double* InputData, double* pn, double* OutputData);
void OtherDataDemodulation(double* InputData, double* pn, double* OutputData);
void Cancellation(double* InputData, double* OutputData);
void DataDecision(double* InputData, double* OutputData);

void main(){

	double* MyData = (double*)calloc(CODE_LENGTH, sizeof(double));
	double* OtherData = (double*)calloc(CODE_LENGTH, sizeof(double));

	double MyPN[CODE_LENGTH] =  {-1,1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1};
	double OtherPN[CODE_LENGTH] = {1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,1,-1,1};

	double* TransmitMyData =  (double*)calloc(CODE_LENGTH, sizeof(double));
	double* TransmitOtherData = (double*)calloc(CODE_LENGTH, sizeof(double));

	double* ReceiveData = (double*)calloc(CODE_LENGTH, sizeof(double));
	double* OutputData = (double*)calloc(CODE_LENGTH, sizeof(double));
	double* SubtractData = (double*)calloc(CODE_LENGTH, sizeof(double));

	double* DecideData = (double*)calloc(CODE_LENGTH, sizeof(double));

	int i, j, k;

	unsigned long MyBER00, OtherBER00;
	unsigned long MyBER01, OtherBER01;
	unsigned long MyBER02, OtherBER02;

	double en;

	double pebs_M00, pebs_M01, pebs_M02;
	double pebs_O00, pebs_O01, pebs_O02;

	double end[P] = {0.0, 5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0};
	double en2 = pow(10.0, SIR/10.0);

	seed = (unsigned long)time(NULL);

	
	//Ž©‹Çƒf[ƒ^‚Ì¶¬(ŠÈ’P‰»‚Ì‚½‚ßall1)
	for(i=0 ; i<CODE_LENGTH ; i++){
		MyData[i] = 1.0;
	}

	//Ž©‹Çƒf[ƒ^•Ï’²
	MakeMyData(MyData, MyPN, TransmitMyData);

	for(i=0 ; i<P ; i++){
		en = pow(10.0, end[i]/10.0);

		for(j=MyBER00=OtherBER00=MyBER01=OtherBER01=MyBER02=OtherBER02=0 ; j<N ; j++){

			//‘¼‹Çƒf[ƒ^‚Ì¶¬
			for(k=0 ; k<CODE_LENGTH ; k++){
				if(rnd()>0.5){
						OtherData[k] = 1.0;
					}else{
						OtherData[k] = -1.0;
					}
			}

			//‘¼‹Çƒf[ƒ^•Ï’²
			MakeOtherData(OtherData, OtherPN, TransmitOtherData);

			//ŽóMM†‚Ìì¬
			for(k=0 ; k<CODE_LENGTH ; k++){
				ReceiveData[k] = TransmitMyData[k] + (TransmitOtherData[k] / sqrt(en2)) + nrnd(0, sqrt((CODE_LENGTH)/(2.0*en)));
			}

			//自局データ(干渉除去なし)BER特性導出	
			MyDataDemodulation(ReceiveData, MyPN, OutputData);
			DataDecision(OutputData, DecideData);

			for(k=0 ; k<CODE_LENGTH ; k++){
				if(DecideData[k] != MyData[k]){
					MyBER00++;
				}
			}

			//他局データ(干渉除去なし)BER特性導出
			OtherDataDemodulation(ReceiveData, OtherPN, OutputData);
			DataDecision(OutputData, DecideData);

			for(k=0 ; k<CODE_LENGTH ; k++){
				if(DecideData[k] != OtherData[k]){
					OtherBER00++;
				}
			}

			MakeOtherData(DecideData, OtherPN, OutputData);
			
			//Š±Âœ‹Ž
			for(k=0 ; k<CODE_LENGTH ; k++){
				SubtractData[k] = ReceiveData[k] - (OutputData[k]/sqrt(en2)) ;
			}

			//Ž©‹ÇM†‚Ì•œ’²
			MyDataDemodulation(SubtractData, MyPN, OutputData);
			//”»’è
			DataDecision(OutputData, DecideData);

			//自局データ(干渉除去1回目)BER特性導出
			for(k=0 ; k<CODE_LENGTH ; k++){
				if(DecideData[k] != MyData[k]){
					MyBER01++;
				}
			}

			//自局データ生成
			MakeMyData(DecideData, MyPN, OutputData);

			//干渉除去
			for(k=0 ; k<CODE_LENGTH ; k++){
				SubtractData[k] = ReceiveData[k] - OutputData[k];
			}

			OtherDataDemodulation(SubtractData, OtherPN, OutputData);
			DataDecision(OutputData, DecideData);

			//他局データ(干渉除去1回目)BER特性導出
			for(k=0 ; k<CODE_LENGTH ; k++){
				if(DecideData[k] != OtherData[k]){
					OtherBER01++;
				}
			}

			MakeOtherData(DecideData, OtherPN, OutputData);

			for(k=0 ; k<CODE_LENGTH ; k++){
				SubtractData[k] = ReceiveData[k] - (OutputData[k]/sqrt(en2)) ;
			}

			//Ž©‹ÇM†‚Ì•œ’²
			MyDataDemodulation(SubtractData, MyPN, OutputData);
			//”»’è
			DataDecision(OutputData, DecideData);

			//自局データ(干渉除去2回目)BER特性導出
			for(k=0 ; k<CODE_LENGTH ; k++){
				if(DecideData[k] != MyData[k]){
					MyBER02++;
				}
			}

			MakeMyData(DecideData, MyPN, OutputData);

			//干渉除去
			for(k=0 ; k<CODE_LENGTH ; k++){
				SubtractData[k] = ReceiveData[k] - OutputData[k];
			}

			OtherDataDemodulation(SubtractData, OtherPN, OutputData);
			DataDecision(OutputData, DecideData);

			//他局データ(干渉除去2回目)BER特性導出
			for(k=0 ; k<CODE_LENGTH ; k++){
				if(DecideData[k] != OtherData[k]){
					OtherBER02++;
				}
			}
		}

		pebs_M00 = (double)MyBER00 / (double)(N*32);	pebs_O00 = (double)OtherBER00 / (double)(N*32);
		pebs_M01 = (double)MyBER01 / (double)(N*32);	pebs_O01 = (double)OtherBER01 / (double)(N*32);
		pebs_M02 = (double)MyBER02 / (double)(N*32);	pebs_O02 = (double)OtherBER02 / (double)(N*32);

		printf("Eb/No\tMyData00\tMyData01\tMyData02\tOtherData00\tOtherData01\tOtherData02\n");
		printf("%.1f\t%5.6e\t%5.6e\t%5.6e\t%5.6e\t%5.6e\t%5.6e\n\n", end[i], pebs_M00, pebs_M01, pebs_M02, pebs_O00, pebs_O01, pebs_O02);	
	}
}	

void MakeMyData(double* InputData, double* pn, double* OutputData)
{
	int i, j;

	double WalshCode[CODE_LENGTH][CODE_LENGTH] = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
		{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1},
		{1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1},
		{1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1},
		{1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1},
		{1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1},
		{1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1},
		{1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1},
		{1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1},
		{1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1},
		{1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1},
		{1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1},
		{1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1},
		{1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1},
		{1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1},
		{1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1},
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
		{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1},
		{1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1},
		{1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1},
		{1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1},
		{1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1},
		{1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1},
		{1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1},
		{1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1},
		{1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1},
		{1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1},
		{1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1},
		{1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1},
		{1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1},
		{1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1},
		{1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1}
	};

	//‰Šú‰»
	for(i=0 ; i<CODE_LENGTH ; i++){
		OutputData[i] = 0.0;
	}

	//‘—Mƒf[ƒ^‚Ìì¬
	for(i=0 ; i<CODE_LENGTH ; i++){
		for(j=0 ; j<CODE_LENGTH ; j++){
			OutputData[j] += WalshCode[i][j] * pn[j] * InputData[i];
		}
	}


}

void MakeOtherData(double* InputData, double* pn, double* OutputData)
{
	int i, j;
	double shift[CODE_LENGTH][CODE_LENGTH];		//„‰ñƒVƒtƒg’¼ŒðGoldŒn—ñ‚Ìì¬

	double WalshCode[CODE_LENGTH][CODE_LENGTH] = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
		{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1},
		{1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1},
		{1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1},
		{1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1},
		{1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1},
		{1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1},
		{1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1},
		{1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1},
		{1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1},
		{1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1},
		{1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1},
		{1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1},
		{1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1},
		{1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1},
		{1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1},
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
		{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1},
		{1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1},
		{1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1},
		{1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1},
		{1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1},
		{1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1},
		{1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1},
		{1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1},
		{1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1},
		{1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1},
		{1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1},
		{1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1},
		{1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1},
		{1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1},
		{1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1}
	};

	//„‰ñƒVƒtƒg’¼ŒðGoldŒn—ñ‚Ìì¬
	for(i=0 ; i<CODE_LENGTH ; i++){
		for(j=0 ; j<CODE_LENGTH ; j++){
			shift[i][j] = pn[(i+j)%(CODE_LENGTH)];
		}
	}

	//‰Šú‰»
	for(i=0 ; i<CODE_LENGTH ; i++){
		OutputData[i] = 0.0;
	}

	//‘—Mƒf[ƒ^‚Ìì¬
	for(i=0 ; i<CODE_LENGTH ; i++){
		for(j=0 ; j<CODE_LENGTH ; j++){
			OutputData[j] += WalshCode[i][j] * pn[j] * InputData[i];
		}
	}
}	

void MyDataDemodulation(double* InputData, double* pn, double* OutputData)
{
	int i, j;

	double WalshCode[CODE_LENGTH][CODE_LENGTH] = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
		{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1},
		{1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1},
		{1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1},
		{1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1},
		{1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1},
		{1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1},
		{1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1},
		{1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1},
		{1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1},
		{1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1},
		{1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1},
		{1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1},
		{1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1},
		{1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1},
		{1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1},
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
		{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1},
		{1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1},
		{1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1},
		{1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1},
		{1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1},
		{1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1},
		{1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1},
		{1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1},
		{1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1},
		{1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1},
		{1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1},
		{1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1},
		{1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1},
		{1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1},
		{1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1}
	};

	double WhipData[CODE_LENGTH][CODE_LENGTH];
	double IntegralData[CODE_LENGTH];

	//‰Šú‰»
	for(i=0 ; i<CODE_LENGTH ; i++){
		IntegralData[i] = 0.0;
		OutputData[i] = 0.0;
	}

	//ŽóMM†‚ÉWalsh•„†‚ÆPNŒn—ñ‚ÌŠes‚ðæŽZ
	for(i=0 ; i<CODE_LENGTH ; i++){
		for(j=0 ; j<CODE_LENGTH ; j++){
			WhipData[i][j] = InputData[j] * WalshCode[i][j] * pn[j];
		}
	}
	
	//Žæ‚èo‚µ‚½ƒf[ƒ^‚ðÏ•ª
	for(i=0 ; i<CODE_LENGTH; i++){
		for(j=0 ; j<CODE_LENGTH ; j++){
			IntegralData[i] += WhipData[i][j];
		}
	}

	//Ï•ª‚µ‚½ƒf[ƒ^‚ð•„†’·‚ÅŠ„‚é
	for(i=0 ; i<CODE_LENGTH ; i++){
		OutputData[i] = IntegralData[i] / CODE_LENGTH;
	}	
}

void OtherDataDemodulation(double* InputData, double* pn, double* OutputData)
{
	int i, j;
	double shift[CODE_LENGTH][CODE_LENGTH];		//„‰ñƒVƒtƒg’¼ŒðGoldŒn—ñ‚Ìì¬

	double WalshCode[CODE_LENGTH][CODE_LENGTH] = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
		{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1},
		{1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1},
		{1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1},
		{1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1},
		{1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1},
		{1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1},
		{1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1},
		{1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1},
		{1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1},
		{1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1},
		{1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1},
		{1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1},
		{1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1},
		{1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1},
		{1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1},
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
		{1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1},
		{1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1},
		{1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1},
		{1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1},
		{1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1},
		{1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1},
		{1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1},
		{1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1},
		{1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1},
		{1,1,-1,-1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1},
		{1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1},
		{1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1},
		{1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1},
		{1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,1},
		{1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1}
	};

	double WhipData[CODE_LENGTH][CODE_LENGTH];
	double IntegralData[CODE_LENGTH];

	//„‰ñƒVƒtƒg’¼ŒðGoldŒn—ñ‚Ìì¬
	for(i=0 ; i<CODE_LENGTH ; i++){
		for(j=0 ; j<CODE_LENGTH ; j++){
			shift[i][j] = pn[(i+j)%(CODE_LENGTH)];
		}
	}

	//‰Šú‰»
	for(i=0 ; i<CODE_LENGTH ; i++){
		IntegralData[i] = 0.0;
	}

	//ŽóMM†‚ÉWalsh•„†‚ÆPNŒn—ñ‚ÌŠes‚ðæŽZ
	for(i=0 ; i<CODE_LENGTH ; i++){
		for(j=0 ; j<CODE_LENGTH ; j++){
			WhipData[i][j] = InputData[j] * WalshCode[i][j] * shift[NUM][j];
		}
	}
	
	//Žæ‚èo‚µ‚½ƒf[ƒ^‚ðÏ•ª
	for(i=0 ; i<CODE_LENGTH; i++){
		for(j=0 ; j<CODE_LENGTH ; j++){
			IntegralData[i] += WhipData[i][j];
		}
	}

	//Ï•ª‚µ‚½ƒf[ƒ^‚ð•„†’·‚ÅŠ„‚é
	for(i=0 ; i<CODE_LENGTH ; i++){
		OutputData[i] = IntegralData[i] / CODE_LENGTH;
	}	
}

void DataDecision(double* InputData, double* OutputData)
{
	int i;

	for(i=0 ; i<CODE_LENGTH ; i++){
		if(InputData[i] > 0.0){
			OutputData[i] = 1.0;
		}else if(InputData[i] < 0.0){
			OutputData[i] = -1.0;
		}else{
			if(rnd()>0.5){
					OutputData[i] = 1.0;
				}else{
					OutputData[i] = -1.0;
				}
		}
	}
}
